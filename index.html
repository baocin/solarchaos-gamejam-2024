<html>

<head>
  <!-- <base
    href="https://solarchaos.io/?2d=true&multiplayer=peerjs&join_automatically&join_code_visible&goal=extinguish%20the%20sun&mechanics=%5B'drag%20arrow%20between%20planets%20to%20trade%20user%20planet%20resource%20with%20target%20planet%20resource',%20'each%20planet%20represents%20a%20user',%20'user%20only%20controls%20trade%20and%20attack%20from%20their%20planet',%20'user%20planet%20only%20generates%20assigned%20resource',%20'drag%20arrow%20from%20planet%20to%20sun%20to%20extinguish%20sun',%20'attack%20ship%20costs%201%20of%20each%20resource',%20'trade%20ships%20are%20free'%5D&inspiration=galcon&planet_orbit_speed=0.1rad/s&join_code_via_textbox&production=true&game_version=3&paid_via_steam&sun_default_health=100&planet_resource_visible_to_all_players=true&hover_over_planet_to_see_planets_resources=true&win=sun%20goes%20dark&origin=sun&use_join_uuid_peerjs"> -->
  <title>Solar Chaos v3 - Multiplayer Sun Extinguishing Game</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>

<body>
  <div id="game-container" onmousedown="event.preventDefault();">
    <div id="sun"></div>
    <div id="sun-health">Sun Health: 100</div>
    <div id="hud">
      <h2>Solar Chaos v3</h2>
      <p>Goal: Extinguish the Sun</p>
      <div id="player-info"></div>
      <div id="resources"></div>
    </div>
    <div id="join-container">
      <h3>Solar Chaos v3</h3>
      <input type="text" id="join-code-input" placeholder="Enter game code">
      <button id="join-button">Join Game</button>
      <button id="create-game-button">Create New Game</button>
    </div>
    <div id="message-log"></div>
    <div id="game-code"></div>
    <div id="players-list"></div>
    <div id="win-message"></div>
  </div>

  <script src="https://steele.red/solarchaos/peerjs.min.js"></script>
  <script>
    const planets = [
      { id: 'mercury', name: 'Mercury', color: '#8c7853', size: 15, orbitRadius: 100, resource: 'steel', orbitSpeed: 0.2 },
      { id: 'venus', name: 'Venus', color: '#e6e6fa', size: 22, orbitRadius: 150, resource: 'engine', orbitSpeed: 0.15 },
      { id: 'earth', name: 'Earth', color: '#4169e1', size: 25, orbitRadius: 200, resource: 'water', orbitSpeed: 0.1 },
      { id: 'mars', name: 'Mars', color: '#b22222', size: 20, orbitRadius: 250, resource: 'fuel', orbitSpeed: 0.08 },
      { id: 'jupiter', name: 'Jupiter', color: '#ffa500', size: 45, orbitRadius: 350, resource: 'people', orbitSpeed: 0.05 }
    ];

    const resourceIcons = {
      steel: '\uD83D\uDD27',  // ðŸ”§
      engine: '\uD83D\uDE80', // ðŸš€
      water: '\uD83D\uDCA7',  // ðŸ’§
      fuel: '\u26FD',         // â›½
      people: '\uD83D\uDC65'  // ðŸ‘¥
    };

    let userPlanet;
    let resources = { steel: 0, engine: 0, water: 0, fuel: 0, people: 0 };
    let sunHealth = 100;
    let players = [];
    let peer;
    let connections = [];
    let gameStarted = false;
    let tradeLines = [];

    const container = document.getElementById('game-container');
    const joinContainer = document.getElementById('join-container');
    const joinCodeInput = document.getElementById('join-code-input');
    const joinButton = document.getElementById('join-button');
    const createGameButton = document.getElementById('create-game-button');
    const messageLog = document.getElementById('message-log');
    const playerInfo = document.getElementById('player-info');
    const resourcesDisplay = document.getElementById('resources');
    const sunHealthDisplay = document.getElementById('sun-health');
    const gameCodeDisplay = document.getElementById('game-code');
    const playersListDisplay = document.getElementById('players-list');
    const winMessageDisplay = document.getElementById('win-message');
    const sunElement = document.getElementById('sun');

    function initializeGame() {
      const storedPlayerId = localStorage.getItem('playerId');
      if (storedPlayerId) {
        peer = new Peer(storedPlayerId);
      } else {
        peer = new Peer(generateUUID());
      }

      peer.on('open', (id) => {
        console.log('My peer ID is: ' + id);
        gameCodeDisplay.textContent = `Game Code: ${id}`;
        localStorage.setItem('playerId', id);
      });

      peer.on('connection', (conn) => {
        handleConnection(conn);
      });

      createGameButton.addEventListener('click', createGame);
      joinButton.addEventListener('click', joinGame);
    }

    function createGame() {
      gameStarted = true;
      joinContainer.style.display = 'none';
      setupPlanets();
      assignUserPlanet();
      broadcastGameState();
      setInterval(broadcastGameState, 1000); // Broadcast game state every second
      setInterval(updateTradeLines, 100); // Update trade lines every 100ms
    }

    function joinGame() {
      if (gameStarted) {
        alert("You have already joined or created a game.");
        return;
      }

      const joinCode = joinCodeInput.value.trim();
      if (joinCode) {
        createGame();
        const conn = peer.connect(joinCode);
        conn.on('open', () => {
          handleConnection(conn);
          conn.send({ type: 'requestGameState' });
        });
      } else {
        alert("Please enter a valid game code");
      }
    }

    function handleConnection(conn) {
      connections.push(conn);

      conn.on('open', () => {
        console.log("Connected to: " + conn.peer);
        if (!gameStarted) {
          gameStarted = true;
          joinContainer.style.display = 'none';
          setupPlanets();
          assignUserPlanet();
        }
        conn.send({ type: 'requestGameState' });
      });

      conn.on('data', (data) => {
        handleReceivedData(data);
      });
    }

    function setupPlanets() {
      planets.forEach((planet, index) => {
        const orbit = document.createElement('div');
        orbit.className = 'orbit';
        orbit.style.width = `${planet.orbitRadius * 2}px`;
        orbit.style.height = `${planet.orbitRadius * 2}px`;
        orbit.style.top = `${window.innerHeight / 2 - planet.orbitRadius}px`;
        orbit.style.left = `${window.innerWidth / 2 - planet.orbitRadius}px`;
        container.appendChild(orbit);

        const el = document.createElement('div');
        el.className = 'planet';
        el.id = planet.id;
        el.style.width = `${planet.size}px`;
        el.style.height = `${planet.size}px`;
        el.style.backgroundColor = planet.color;
        container.appendChild(el);
        planet.element = el;

        const label = document.createElement('div');
        label.className = 'planet-label';
        label.textContent = `${planet.name}\n${resourceIcons[planet.resource]}`;
        container.appendChild(label);
        planet.label = label;

        const resourcesInfo = document.createElement('div');
        resourcesInfo.className = 'planet-resources';
        container.appendChild(resourcesInfo);
        planet.resourcesInfo = resourcesInfo;

        el.addEventListener('mouseover', () => showPlanetResources(planet));
        el.addEventListener('mouseout', () => hidePlanetResources(planet));

        players.push({
          name: `Player ${index + 1}`,
          planet: planet,
          resources: { ...resources }
        });
      });

      updatePlanetPositions();
      setInterval(updateResources, 1000);
      updatePlayersList();
    }

    function assignUserPlanet() {
      const availablePlanets = planets.filter(p => !players.some(player => player.planet === p && player.name !== `Player ${planets.indexOf(p) + 1}`));
      if (availablePlanets.length > 0) {
        userPlanet = availablePlanets[Math.floor(Math.random() * availablePlanets.length)];
        const newPlayer = players.find(p => p.planet === userPlanet);
        newPlayer.name = "You";
        playerInfo.textContent = `Your Planet: ${userPlanet.name} (${userPlanet.resource})`;
        logMessage(`You control ${userPlanet.name}, producing ${userPlanet.resource}`);
        updatePlayersList();
      } else {
        logMessage("All planets are occupied. Spectating mode active.");
      }
    }

    function showPlanetResources(planet) {
      const player = players.find(p => p.planet === planet);
      if (player) {
        const resourcesList = Object.entries(player.resources)
          .map(([resource, amount]) => `${resourceIcons[resource]} ${resource}: ${amount}`)
          .join('<br>');
        planet.resourcesInfo.innerHTML = resourcesList;
        planet.resourcesInfo.style.display = 'block';
        positionResourcesInfo(planet);
      }
    }

    function hidePlanetResources(planet) {
      planet.resourcesInfo.style.display = 'none';
    }

    function positionResourcesInfo(planet) {
      const rect = planet.element.getBoundingClientRect();
      planet.resourcesInfo.style.left = `${rect.right + 10}px`;
      planet.resourcesInfo.style.top = `${rect.top}px`;
    }

    function updatePlanetPositions() {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;

      planets.forEach((planet, index) => {
        if (planet.element) {
          const { x, y } = calculatePlanetPosition(planet);
          planet.element.style.left = `${x}px`;
          planet.element.style.top = `${y}px`;

          planet.label.style.left = `${x + planet.size / 2 - 30}px`;
          planet.label.style.top = `${y + planet.size + 5}px`;
        }

        positionResourcesInfo(planet);
      });

      requestAnimationFrame(updatePlanetPositions);
    }

    function calculatePlanetPosition(planet, futureTime = 0) {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const currentTime = Date.now() + futureTime;
      const angle = (currentTime / 1000) * planet.orbitSpeed;
      const x = centerX + Math.cos(angle) * planet.orbitRadius;
      const y = centerY + Math.sin(angle) * planet.orbitRadius;
      return { x, y };
    }

    function updateResources() {
      if (gameStarted) {
        players.forEach(player => {
          player.resources[player.planet.resource]++;
        });
        updateResourcesDisplay();
        updatePlayersList();
        broadcastGameState();
      }
    }

    function updateResourcesDisplay() {
      if (userPlanet) {
        const player = players.find(p => p.planet === userPlanet);
        resourcesDisplay.innerHTML = Object.entries(player.resources)
          .map(([resource, amount]) => `
        <div class="resource">
          <span class="resource-icon">${resourceIcons[resource]}</span>
          <span>${resource}: ${amount}</span>
        </div>
      `).join('');
      }
    }

    function updatePlayersList() {
      playersListDisplay.innerHTML = '<h3>Players</h3>' + players.map(player =>
        `<div>${player.name} (${player.planet.name}): ${resourceIcons[player.planet.resource]}</div>`
      ).join('');
    }

    function logMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.textContent = message;
      messageLog.appendChild(messageElement);
      messageLog.scrollTop = messageLog.scrollHeight;
    }

    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    let isDragging = false;
    let startPlanet = null;
    let currentArrow = null;

    function startDrag(e) {
      if (gameStarted && e.target.classList.contains('planet') &&
        e.target === userPlanet.element) {
        isDragging = true;
        startPlanet = e.target;
        currentArrow = document.createElement('div');
        currentArrow.className = 'arrow';
        container.appendChild(currentArrow);
      }
    }

    function moveDrag(e) {
      if (isDragging && startPlanet) {
        const startRect = startPlanet.getBoundingClientRect();
        const startX = startRect.left + startRect.width / 2;
        const startY = startRect.top + startRect.height / 2;

        const endX = e.clientX || e.touches[0].clientX;
        const endY = e.clientY || e.touches[0].clientY;

        const angle = Math.atan2(endY - startY, endX - startX);
        const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);

        currentArrow.style.left = `${startX}px`;
        currentArrow.style.top = `${startY}px`;
        currentArrow.style.width = `${length}px`;
        currentArrow.style.transform = `rotate(${angle}rad)`;
      }
    }

    function endDrag(e) {
      if (isDragging) {
        isDragging = false;
        if (currentArrow) {
          const endX = e.clientX || e.changedTouches[0].clientX;
          const endY = e.clientY || e.changedTouches[0].clientY;
          const sourcePlanetObject = planets.find(p => p.element === startPlanet);
          let { x: startX, y: startY } = calculatePlanetPosition(sourcePlanetObject);

          const targetElement = e.target;
          const isSunTarget = targetElement.id === 'sun';

          // Adjust end coordinates if the target is the sun
          if (isSunTarget) {
            const sunRect = sunElement.getBoundingClientRect();
            endX = sunRect.left + sunRect.width / 2;
            endY = sunRect.top + sunRect.height / 2;
          }

          const angle = Math.atan2(endY - startY, endX - startX);
          const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
          
          const tradeLine = {
            element: currentArrow,
            startX,
            startY,
            endX,
            endY,
            angle,
            length,
            sourcePlanet: startPlanet,
            targetElement: targetElement,
            progress: 0,
            isSunTarget: isSunTarget
          };

          tradeLines.push(tradeLine);
          broadcastTradeLines();

          currentArrow = null;
        }
        startPlanet = null;
      }
    }

    container.addEventListener('mousedown', startDrag);
    container.addEventListener('mousemove', moveDrag);
    container.addEventListener('mouseup', endDrag);

    container.addEventListener('touchstart', startDrag);
    container.addEventListener('touchmove', moveDrag);
    container.addEventListener('touchend', endDrag);

    function updateTradeLines() {
      tradeLines.forEach((line, index) => {
        line.progress += 0.01; // Increment progress
        if (line.progress >= 1) {
          // Trade line completed
          const sourcePlayer = players.find(p => p.planet.element === line.sourcePlanet);
          const targetPlanet = planets.find(p => p.element === line.targetElement);
          const targetResource = line.isSunTarget ? 'Sun' : targetPlanet ? targetPlanet.resource : null;
          const sourceResource = sourcePlayer.planet.resource;

          if (targetResource === 'Sun') {
            // Decrease sun health
            sunHealth = Math.max(0, sunHealth - 1);
            sunHealthDisplay.textContent = `Sun Health: ${sunHealth}`;
            updateSunAppearance();
            logMessage(`Attack on Sun: -1 health (Current: ${sunHealth})`);
            if (sunHealth === 0) {
              endGame();
            }
          } else if (targetResource) {
            const targetPlayer = players.find(p => p.planet.resource === targetResource);
            sourcePlayer.resources[targetResource]++;
            targetPlayer.resources[targetResource]--;
            logMessage(`Trade completed: 1 ${sourceResource} received from ${targetPlayer.name}`);
          }

          container.removeChild(line.element);
          tradeLines.splice(index, 1);
          broadcastTradeLines();
          broadcastGameState();
        } else {
          // Continuously update trade line to target the sourcePlanetObject
          const sourcePlanetObject = planets.find(p => p.element === line.sourcePlanet);
          const { x: startX, y: startY } = calculatePlanetPosition(sourcePlanetObject);
          
          let endX, endY;
          if (line.isSunTarget) {
            const sunRect = sunElement.getBoundingClientRect();
            endX = sunRect.left + sunRect.width / 2;
            endY = sunRect.top + sunRect.height / 2;
          } else {
            endX = line.endX;
            endY = line.endY;
          }

          const angle = Math.atan2(endY - startY, endX - startX);
          const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);

          line.startX = startX;
          line.startY = startY;
          line.endX = endX;
          line.endY = endY;
          line.angle = angle;
          line.length = length;

          // Update trade line appearance
          const newLength = line.length * (1 - line.progress);
          line.element.style.left = `${line.startX}px`;
          line.element.style.top = `${line.startY}px`;
          line.element.style.width = `${newLength}px`;
          line.element.style.transform = `rotate(${line.angle}rad)`;
        }
      });
    }

    function broadcastTradeLines() {
      const tradeLinesData = tradeLines.map(line => ({
        startX: line.startX,
        startY: line.startY,
        endX: line.endX,
        endY: line.endY,
        angle: line.angle,
        length: line.length,
        progress: line.progress,
        sourcePlanetId: line.sourcePlanet.id,
        targetElementId: line.targetElement.id,
        isSunTarget: line.isSunTarget
      }));

      connections.forEach(conn => conn.send({ type: 'tradeLines', tradeLines: tradeLinesData }));
    }

    function updateSunAppearance() {
      const opacity = sunHealth / 100;
      sunElement.style.opacity = opacity;
      sunElement.style.boxShadow = `0 0 ${50 * opacity}px #ff6600`;
    }

    function endGame() {
      logMessage("Congratulations! The sun has been extinguished!");
      winMessageDisplay.textContent = "You Win! The sun has gone dark.";
      winMessageDisplay.style.display = "block";
      gameStarted = false;
      broadcastGameState();
    }

    function broadcastGameState() {
      const gameState = {
        type: 'gameState',
        players: players.map(player => ({
          name: player.name,
          planet: {
            id: player.planet.id,
            name: player.planet.name,
            resource: player.planet.resource
          },
          resources: player.resources
        })),
        sunHealth: sunHealth,
        tradeLines: tradeLines.map(line => ({
          startX: line.startX,
          startY: line.startY,
          endX: line.endX,
          endY: line.endY,
          angle: line.angle,
          length: line.length,
          progress: line.progress,
          sourcePlanetId: line.sourcePlanet.id,
          targetElementId: line.targetElement.id,
          isSunTarget: line.isSunTarget
        }))
      };
      connections.forEach(conn => conn.send(gameState));
    }

    function handleReceivedData(data) {
      if (data.type === 'gameState') {
        players = data.players.map(player => ({
          name: player.name,
          planet: planets.find(p => p.id === player.planet.id),
          resources: player.resources
        }));
        sunHealth = data.sunHealth;
        updateResourcesDisplay();
        updatePlayersList();
        updateSunAppearance();
        sunHealthDisplay.textContent = `Sun Health: ${sunHealth}`;
        if (sunHealth === 0) {
          endGame();
        }
        tradeLines = data.tradeLines.map(line => {
          const element = document.createElement('div');
          element.className = 'arrow';
          element.style.left = `${line.startX}px`;
          element.style.top = `${line.startY}px`;
          element.style.width = `${line.length}px`;
          element.style.transform = `rotate(${line.angle}rad)`;
          container.appendChild(element);

          return {
            element,
            startX: line.startX,
            startY: line.startY,
            endX: line.endX,
            endY: line.endY,
            angle: line.angle,
            length: line.length,
            progress: line.progress,
            sourcePlanet: planets.find(p => p.id === line.sourcePlanetId).element,
            targetElement: document.getElementById(line.targetElementId),
            isSunTarget: line.isSunTarget
          };
        });
      } else if (data.type === 'requestGameState') {
        broadcastGameState();
      } else if (data.type === 'tradeLines') {
        tradeLines.forEach(line => container.removeChild(line.element));
        tradeLines = data.tradeLines.map(line => {
          const element = document.createElement('div');
          element.className = 'arrow';
          element.style.left = `${line.startX}px`;
          element.style.top = `${line.startY}px`;
          element.style.width = `${line.length}px`;
          element.style.transform = `rotate(${line.angle}rad)`;
          container.appendChild(element);

          return {
            element,
            startX: line.startX,
            startY: line.startY,
            endX: line.endX,
            endY: line.endY,
            angle: line.angle,
            length: line.length,
            progress: line.progress,
            sourcePlanet: planets.find(p => p.id === line.sourcePlanetId).element,
            targetElement: document.getElementById(line.targetElementId),
            isSunTarget: line.isSunTarget
          };
        });
      }
    }

    initializeGame();
  </script>
</body>

</html>